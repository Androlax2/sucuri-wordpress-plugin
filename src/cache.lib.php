<?php

/**
 * Code related to the cache.lib.php interface.
 *
 * @package Sucuri Security
 * @subpackage cache.lib.php
 * @copyright Since 2010 Sucuri Inc.
 */

if (!defined('SUCURISCAN_INIT') || SUCURISCAN_INIT !== true) {
    if (!headers_sent()) {
        /* Report invalid access if possible. */
        header('HTTP/1.1 403 Forbidden');
    }
    exit(1);
}

/**
 * File-based cache library.
 *
 * WP_Object_Cache [1] is WordPress' class for caching data which may be
 * computationally expensive to regenerate, such as the result of complex
 * database queries. However the object cache is non-persistent. This means that
 * data stored in the cache resides in memory only and only for the duration of
 * the request. Cached data will not be stored persistently across page loads
 * unless of the installation of a 3party persistent caching plugin [2].
 *
 * [1] https://codex.wordpress.org/Class_Reference/WP_Object_Cache
 * [2] https://codex.wordpress.org/Class_Reference/WP_Object_Cache#Persistent_Caching
 */
class SucuriScanCache extends SucuriScan
{
    /**
     * The unique name (or identifier) of the file with the data.
     *
     * The file should be located in the same folder where the dynamic data
     * generated by the plugin is stored, and using the following format [1], it
     * most be a PHP file because it is expected to have an exit point in the first
     * line of the file causing it to stop the execution if a unauthorized user
     * tries to access it directly.
     *
     * [1] /public/data/sucuri-DATASTORE.php
     *
     * @var null|string
     */
    private $datastore = null;

    /**
     * The full path of the datastore file.
     *
     * @var string
     */
    private $datastore_path = '';

    /**
     * Whether the datastore file is usable or not.
     *
     * This variable will only be TRUE if the datastore file specified exists, is
     * writable and readable, in any other case it will always be FALSE.
     *
     * @var boolean
     */
    private $usable_datastore = false;

    /**
     * Initializes the cache library.
     *
     * @param string $datastore Name of the storage file.
     * @param bool $auto_create Forces the creation of the storage file.
     */
    public function __construct($datastore = '', $auto_create = true)
    {
        $this->datastore = $datastore;
        $this->datastore_path = $this->datastoreFilePath($auto_create);
        $this->usable_datastore = (bool) $this->datastore_path;
    }

    /**
     * Default attributes for every datastore file.
     *
     * @return array Default attributes for every datastore file.
     */
    private function datastoreDefaultInfo()
    {
        $attrs = array(
            'datastore' => $this->datastore,
            'created_on' => time(),
            'updated_on' => time(),
        );

        return $attrs;
    }

    /**
     * Default content of every datastore file.
     *
     * @param array $finfo Rainbow table with the key names and decoded values.
     * @return string Default content of every datastore file.
     */
    private function datastoreInfo($finfo = array())
    {
        $attrs = $this->datastoreDefaultInfo();
        $info_is_available = (bool) isset($finfo['info']);
        $info  = "<?php\n";

        foreach ($attrs as $attr_name => $attr_value) {
            if ($info_is_available
                && $attr_name != 'updated_on'
                && isset($finfo['info'][$attr_name])
            ) {
                $attr_value = $finfo['info'][$attr_name];
            }

            $info .= sprintf("// %s=%s;\n", $attr_name, $attr_value);
        }

        $info .= "exit(0);\n";
        $info .= "?>\n";

        return $info;
    }

    /**
     * Check if the datastore file exists, if it's writable and readable by the same
     * user running the server, in case that it does not exists the method will
     * tries to create it by itself with the right permissions to use it.
     *
     * @param bool $auto_create Create the file is it does not exists.
     * @return string|bool Absolute path to the storage file, false otherwise.
     */
    private function datastoreFilePath($auto_create = false)
    {
        if (!$this->datastore) {
            return false;
        }

        $folder_path = $this->dataStorePath();
        $file_path = $folder_path . '/sucuri-' . $this->datastore . '.php';

        // Create the datastore parent directory.
        if (!file_exists($folder_path)) {
            @mkdir($folder_path, 0755, true);
        }

        // Create the datastore file is it does not exists and the folder is writable.
        if (!file_exists($file_path)
            && is_writable($folder_path)
            && $auto_create === true
        ) {
            @file_put_contents($file_path, $this->datastoreInfo());
        }

        // Continue the operation after an attemp to create the datastore file.
        if (!file_exists($file_path)
            || !is_writable($file_path)
            || !is_readable($file_path)
        ) {
            return false;
        }

        return $file_path;
    }

    /**
     * Define the pattern for the regular expression that will check if a cache key
     * is valid or not, and also will help the method that parses the file to see
     * which characters of each line are the keys are which are the values.
     *
     * @param string $action Either "valid", "content", or "header".
     * @return string Cache key pattern.
     */
    private function keyPattern($action = 'valid')
    {
        if ($action == 'valid') {
            return '/^([0-9a-zA-Z_]+)$/';
        }

        if ($action == 'content') {
            return '/^([0-9a-zA-Z_]+):(.+)/';
        }

        if ($action == 'header') {
            return '/^\/\/ ([a-z_]+)=(.*);$/';
        }

        return '/^$/'; /* match nothing */
    }

    /**
     * Check whether a key has a valid name or not.
     *
     * @param string $key Unique name for the data.
     * @return bool TRUE if the format of the key name is valid, FALSE otherwise.
     */
    private function validKeyName($key = '')
    {
        return (bool) @preg_match($this->keyPattern('valid'), $key);
    }

    /**
     * Update the content of the datastore file with the new entries.
     *
     * @param array $finfo Rainbow table with the key names and decoded values.
     * @return bool TRUE if the operation finished successfully, FALSE otherwise.
     */
    private function saveNewEntries($finfo = array())
    {
        $data_string = $this->datastoreInfo($finfo);

        if (!empty($finfo)) {
            foreach ($finfo['entries'] as $key => $data) {
                if ($this->validKeyName($key)) {
                    $data = json_encode($data);
                    $data_string .= sprintf("%s:%s\n", $key, $data);
                }
            }
        }

        return (bool) @file_put_contents($this->datastore_path, $data_string);
    }

    /**
     * Retrieve and parse the datastore file, and generate a rainbow table with the
     * key names and decoded data as the values of each entry. Duplicated key names
     * will be removed automatically while adding the keys to the array and their
     * values will correspond to the first occurrence found in the file.
     *
     * @param bool $assoc When TRUE returned objects will be converted into associative arrays.
     * @return array Rainbow table with the key names and decoded values.
     */
    private function getDatastoreContent($assoc = false)
    {
        $data_object = array(
            'info' => array(),
            'entries' => array(),
        );

        if ($this->usable_datastore) {
            $data_lines = SucuriScanFileInfo::fileLines($this->datastore_path);

            if (!empty($data_lines)) {
                foreach ($data_lines as $line) {
                    if (preg_match($this->keyPattern('header'), $line, $match)) {
                        $data_object['info'][ $match[1] ] = $match[2];
                    } elseif (preg_match($this->keyPattern('content'), $line, $match)) {
                        if ($this->validKeyName($match[1])
                            && !array_key_exists($match[1], $data_object)
                        ) {
                            $data_object['entries'][$match[1]] = @json_decode($match[2], $assoc);
                        }
                    }
                }
            }
        }

        return $data_object;
    }

    /**
     * Retrieve the headers of the datastore file.
     *
     * Each datastore file has a list of attributes at the beginning of the it with
     * information like the creation and last update time. If you are extending the
     * functionality of these headers please refer to the method that contains the
     * default attributes and their values [1].
     *
     * [1] SucuriScanCache::datastoreDefaultInfo()
     *
     * @return array|bool Default content of every datastore file.
     */
    public function getDatastoreInfo()
    {
        $finfo = $this->getDatastoreContent();

        if (empty($finfo['info'])) {
            return false;
        }

        $finfo['info']['fpath'] = $this->datastore_path;

        return $finfo['info'];
    }

    /**
     * Get the total number of unique entries in the datastore file.
     *
     * @param array $finfo Rainbow table with the key names and decoded values.
     * @return int Total number of unique entries found in the datastore file.
     */
    public function getCount($finfo = null)
    {
        if (!is_array($finfo)) {
            $finfo = $this->getDatastoreContent();
        }

        return count($finfo['entries']);
    }

    /**
     * Check whether the last update time of the datastore file has surpassed the
     * lifetime specified for a key name. This method is the only one related with
     * the caching process, any others besides this are just methods used to handle
     * the data inside those files.
     *
     * @param int $lifetime Life time of the key in the datastore file.
     * @param array $finfo Rainbow table with the key names and decoded values.
     * @return bool TRUE if the life time of the data has expired, FALSE otherwise.
     */
    public function dataHasExpired($lifetime = 0, $finfo = null)
    {
        if (is_null($finfo)) {
            $finfo = $this->getDatastoreContent();
        }

        if ($lifetime > 0 && !empty($finfo['info'])) {
            $diff_time = time() - intval($finfo['info']['updated_on']);

            if ($diff_time >= $lifetime) {
                return true;
            }
        }

        return false;
    }

    /**
     * Execute the action using the key name and data specified.
     *
     * @param string $key Unique name for the data.
     * @param mixed $data Data to associate to the key.
     * @param string $action Either add, set, get, or delete.
     * @param int $lifetime Life time of the key in the datastore file.
     * @param bool $assoc When TRUE returned objects will be converted into associative arrays.
     * @return bool TRUE if the operation finished successfully, FALSE otherwise.
     */
    private function handleKeyData($key = '', $data = null, $action = '', $lifetime = 0, $assoc = false)
    {
        if ($this->validKeyName($key)
            && $this->usable_datastore
        ) {
            $finfo = $this->getDatastoreContent($assoc);

            if ($action == 'set' || $action == 'add') {
                $finfo['entries'][$key] = $data;

                return $this->saveNewEntries($finfo);
            } elseif ($action == 'get') {
                if (!$this->dataHasExpired($lifetime, $finfo)
                    && array_key_exists($key, $finfo['entries'])
                ) {
                    return $finfo['entries'][$key];
                }
            } elseif ($action == 'get_all') {
                if (!$this->dataHasExpired($lifetime, $finfo)) {
                    return $finfo['entries'];
                }
            } elseif ($action == 'exists') {
                if (!$this->dataHasExpired($lifetime, $finfo)
                    && array_key_exists($key, $finfo['entries'])
                ) {
                    return true;
                }
            } elseif ($action == 'delete') {
                unset($finfo['entries'][$key]);

                return $this->saveNewEntries($finfo);
            }
        }

        return false;
    }

    /**
     * JSON-encode the data and store it in the datastore file identifying it with
     * the key name, the data will be added to the file even if the key is
     * duplicated, but when getting the value of the same key later again it will
     * return only the value of the first occurrence found in the file.
     *
     * @param string $key Unique name for the data.
     * @param mixed $data Data to associate to the key.
     * @return bool True if the data was cached, false otherwise.
     */
    public function add($key = '', $data = '')
    {
        return $this->handleKeyData($key, $data, 'add');
    }

    /**
     * Update the data of all the key names matching the one specified.
     *
     * @param string $key Unique name for the data.
     * @param mixed $data Data to associate to the key.
     * @return bool True if the cache data was updated, false otherwise.
     */
    public function set($key = '', $data = '')
    {
        return $this->handleKeyData($key, $data, 'set');
    }

    /**
     * Retrieve the first occurrence of the key found in the datastore file.
     *
     * @param string $key Unique name for the data.
     * @param int $lifetime Seconds before the data expires.
     * @param string $assoc Force data to be converted to an array.
     * @return mixed Data associated to the key.
     */
    public function get($key = '', $lifetime = 0, $assoc = '')
    {
        $assoc = ($assoc === 'array' ? true : $assoc);

        return $this->handleKeyData($key, null, 'get', $lifetime, $assoc);
    }

    /**
     * Retrieve all the entries found in the datastore file.
     *
     * @param int $lifetime Life time of the key in the datastore file.
     * @param string $assoc Force data to be converted to an array.
     * @return mixed All the entries stored in the cache file.
     */
    public function getAll($lifetime = 0, $assoc = '')
    {
        $assoc = ($assoc === 'array' ? true : $assoc);

        return $this->handleKeyData('temp', null, 'get_all', $lifetime, $assoc);
    }

    /**
     * Check whether a specific key exists in the datastore file.
     *
     * @param string $key Unique name for the data.
     * @return bool True if the data exists, false otherwise.
     */
    public function exists($key = '')
    {
        return $this->handleKeyData($key, null, 'exists');
    }

    /**
     * Delete any entry from the datastore file matching the key name specified.
     *
     * @param string $key Unique name for the data.
     * @return bool True if the data was deleted, false otherwise.
     */
    public function delete($key = '')
    {
        return $this->handleKeyData($key, null, 'delete');
    }

    /**
     * Remove all the entries from the datastore file.
     *
     * @return bool True, unless the cache file is not writable.
     */
    public function flush()
    {
        $finfo = $this->getDatastoreContent();

        if (array_key_exists('entries', $finfo)) {
            $finfo['entries'] = array();
        }

        return $this->saveNewEntries($finfo);
    }
}
